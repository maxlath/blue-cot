// Generated by CoffeeScript 1.10.0
(function() {
  var Cot, chai, config, expect;

  chai = require('chai');

  expect = chai.expect;

  Cot = require('../cot');

  config = require('./config');

  describe('Cot', function() {
    return it('should include port in host header when port not default for protocol', function() {
      var c1, c2, c3, c4;
      c1 = new Cot({
        port: 80,
        hostname: 'foo'
      });
      expect(c1.hostHeader).to.equal('foo');
      c2 = new Cot({
        port: 8080,
        hostname: 'foo'
      });
      expect(c2.hostHeader).to.equal('foo:8080');
      c3 = new Cot({
        port: 443,
        hostname: 'foo',
        ssl: true
      });
      expect(c3.hostHeader).to.equal('foo');
      c4 = new Cot({
        port: 8080,
        hostname: 'foo',
        ssl: true
      });
      return expect(c4.hostHeader).to.equal('foo:8080');
    });
  });

  describe('DbHandle', function() {
    var cot, db;
    cot = new Cot(config.serverOpts);
    db = cot.db(config.dbName);
    beforeEach(function(done) {
      return cot.jsonRequest('DELETE', '/' + config.dbName).then(function() {
        return cot.jsonRequest('PUT', '/' + config.dbName);
      }).then(function() {
        return db.post({
          _id: 'person-1',
          type: 'person',
          name: 'Will Conant'
        });
      }).then(function() {
        return db.post({
          _id: '_design/test',
          views: {
            testView: {
              map: 'function(d) { emit(d.name, null) }'
            }
          }
        });
      }).asCallback(done);
    });
    describe('#docUrl', function() {
      it('should encode doc ids', function() {
        var encoded;
        encoded = db.docUrl('foo/bar');
        return expect(encoded).to.equal('/test-cot-node/foo%2Fbar');
      });
      return it('should not encode first slash in design doc ids', function() {
        var encoded;
        encoded = db.docUrl('_design/foo/bar');
        return expect(encoded).to.equal('/test-cot-node/_design/foo%2Fbar');
      });
    });
    describe('#info', function() {
      return it('should return database info', function(done) {
        return db.info().then(function(info) {
          expect(info).to.be.a('object');
          return expect(info.doc_count).to.equal(2);
        }).asCallback(done);
      });
    });
    describe('#get', function() {
      return it('should return test document from database', function(done) {
        return db.get('person-1').then(function(doc) {
          expect(doc).to.be.a('object');
          return expect(doc.name).to.equal('Will Conant');
        }).asCallback(done);
      });
    });
    describe('#view', function() {
      return it('should return a single row', function(done) {
        return db.view('test', 'testView', {}).then(function(response) {
          expect(response).to.be.object;
          expect(response.rows).to.be.array;
          expect(response.rows.length).to.equal(1);
          return expect(response.rows[0].key).to.equal('Will Conant');
        }).asCallback(done);
      });
    });
    describe('#put', function() {
      return it('should treat conflicts as expected', function(done) {
        var doc;
        doc = {
          _id: 'put-test'
        };
        return db.put(doc).then(function(response) {
          return db.put(doc).then(function(response) {
            return expect(response.error).to.equal('conflict');
          });
        }).asCallback(done);
      });
    });
    describe('#post', function() {
      return it('should treat conflicts as errors', function(done) {
        var doc;
        doc = {
          _id: 'post-test'
        };
        return db.post(doc).then(function(response) {
          return db.post(doc);
        }).then(function(response) {
          return done(new Error('should not have resolved'));
        })["catch"](function(err) {
          return done();
        });
      });
    });
    describe('#batch', function() {
      return it('should ignore conflicts', function(done) {
        var doc, origRev;
        doc = {
          _id: 'batch-test'
        };
        origRev = void 0;
        return db.post(doc).then(function(response) {
          origRev = response.rev;
          return db.batch(doc);
        }).delay(500).then(function(response) {
          return db.get(doc._id);
        }).then(function(response) {
          return expect(response._rev).to.equal(origRev);
        }).asCallback(done);
      });
    });
    return describe('#exists', function() {
      return it('should return null for nonexistent doc', function(done) {
        return db.exists('does-not-exist').then(function(doc) {
          return expect(doc).to.be["null"];
        }).asCallback(done);
      });
    });
  });

}).call(this);
